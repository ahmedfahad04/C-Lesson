/*
[SQLITE_NOMEM] if memory could not be allocated.
[SQLITE_TOOBIG] might be returned if the size of a string or BLOB exceeds limits

A BLOB (large binary object) is an SQLite data type that stores large objects,
typically large files such as images, music, videos, documents, pdf, etc.
*/

typedef sqlite_int64 i64;  /* 8-byte signed integer */
typedef sqlite_uint64 u64; /* 8-byte unsigned integer */
typedef UINT32_TYPE u32;   /* 4-byte unsigned integer */
typedef UINT16_TYPE u16;   /* 2-byte unsigned integer */
typedef INT16_TYPE i16;    /* 2-byte signed integer */
typedef UINT8_TYPE u8;     /* 1-byte unsigned integer */
typedef INT8_TYPE i8;      /* 1-byte signed integer */

struct sqlite3_str
{
  sqlite3 *db;    /* Optional database for lookaside.  Can be NULL */
  char *zText;    /* The string collected so far */
  u32 nAlloc;     /* Amount of space allocated in zText */
  u32 mxAlloc;    /* Maximum allowed allocation.  0 for no malloc usage */
  u32 nChar;      /* Length of the string so far */
  u8 accError;    /* SQLITE_NOMEM or SQLITE_TOOBIG */
  u8 printfFlags; /* SQLITE_PRINTF flags below */
};

typedef struct sqlite3_str StrAccum; /* Internal alias for sqlite3_str */

/*
** Enlarge the memory allocation on a StrAccum object so that it is
** able to accept at least N more bytes of text.
**
** Return the number of bytes of text that StrAccum is able to accept
** after the attempted enlargement.  The value returned might be zero.
*/

SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum *p, int N)
{

  char *zNew;

  /* Test where we can hold the newly appended string into existing Amount of space allocated in p->zText*/
  assert(p->nChar + (i64)N >= p->nAlloc); /* Only called if really needed */

  /*
  ** The testcase() macro is used to aid in coverage testing.  When
  ** doing coverage testing, the condition inside the argument to
  ** testcase() must be evaluated both true and false in order to
  ** get full branch coverage.  The testcase() macro is inserted
  ** to help ensure adequate test coverage in places where simple
  ** condition/decision coverage is inadequate.  For example, testcase()
  ** can be used to make sure boundary values are tested.  For
  ** bitmask tests, testcase() can be used to make sure each bit
  ** is significant and used at least once.  On switch statements
  ** where multiple cases go to the same block of code, testcase()
  ** can insure that all cases are evaluated.
  */

  if (p->accError)
  {
    // check if memory couldn't be allocated or excceeds limits; If so, then return
    testcase(p->accError == SQLITE_TOOBIG);
    testcase(p->accError == SQLITE_NOMEM);
    return 0;
  }

  /* If the current allocation is zero, then allocate a new buffer. */
  if (p->mxAlloc == 0)
  {
    /*
    ** Set the StrAccum object to an error mode.
    */
    sqlite3StrAccumSetError(p, SQLITE_TOOBIG);
    return p->nAlloc - p->nChar - 1;
  }

  else
  {
    char *zOld = isMalloced(p) ? p->zText : 0;
    i64 szNew = p->nChar;
    szNew += (sqlite3_int64)N + 1;

    if (szNew + p->nChar <= p->mxAlloc)
    {
      /* Force exponential buffer size growth as long as it does not overflow,
      ** to avoid having to call this routine too often */
      szNew += p->nChar;
    }

    if (szNew > p->mxAlloc)
    {
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, SQLITE_TOOBIG);
      return 0;
    }
    else
    {
      p->nAlloc = (int)szNew;
    }
    if (p->db)
    {
      /*sqlite3DbRealloc()
      ** to extend the array so that there is space for a new object at the end.*/
      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
    }
    else
    {
      zNew = sqlite3Realloc(zOld, p->nAlloc);
    }

    if (zNew)
    {
      assert(p->zText != 0 || p->nChar == 0);
      if (!isMalloced(p) && p->nChar > 0)
        memcpy(zNew, p->zText, p->nChar);

      p->zText = zNew;
      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
      p->printfFlags |= SQLITE_PRINTF_MALLOCED;
    }
    else
    {
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, SQLITE_NOMEM);
      return 0;
    }
  }
  return N;
}

/*
When the program executes the function call instruction the "CPU stores the memory address" of the instruction
following the function call, copies the "arguments of the function on the stack" and finally transfers control
to the specified function. The CPU then executes the function code, stores the function return value in a
predefined memory location/register and returns control to the calling function.

This can become overhead if the execution time of function is less than the switching time from the caller function
to called function (callee). For functions that are large and/or perform complex tasks, the overhead of the function
call is usually insignificant compared to the amount of time the function takes to run. However, for small,
commonly-used functions, the time needed to make the function call is often a lot more than the time needed
to actually execute the functionâ€™s code.

This overhead occurs for "small functions" because execution time of small function is less than the switching time.
*/

/* here the called function is quite large and that's why function overhead is insignificant
 so they have used SQLITE_NOINLINE macro to A macro to hint to the compiler that a function should not be inlined.
*/

/*
** The StrAccum "p" is not large enough to accept N new bytes of z[].
** So enlarge if first, then do the append.
**
** This is a helper routine to sqlite3_str_append() that does special-case
** work (enlarging the buffer) using tail recursion, so that the
** sqlite3_str_append() routine can use fast calling semantics.
*/

static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N)
{

  // here the return "N" holds number of bytes I can append to string associated wit p
  N = sqlite3StrAccumEnlarge(p, N);
  if (N > 0)
  {
    memcpy(&p->zText[p->nChar], z, N);
    p->nChar += N;
  }
}

/*
** Append N bytes of text from z to the StrAccum object.  Increase the
** size of the memory allocation for StrAccum if necessary.
*/
SQLITE_API void sqlite3_str_append(sqlite3_str *p, const char *z, int N)
{

  // the appended string and it's length can't be NULL.
  // Means NO text(to be appended) but length>0 -> this can't be possible
  assert(z != 0 || N == 0);
  // the original string, it's length can't be NULL & the memory allocation can't be wrong/overflow
  // Means NO text, length > 0 but memory allocated -> this can't be possible
  assert(p->zText != 0 || p->nChar == 0 || p->accError);
  // Negative string lenght is not allowed
  assert(N >= 0);
  // Detect memory allocation or data access error
  assert(p->accError == 0 || p->nAlloc == 0 || p->mxAlloc == 0);

  /* Test where we can hold the newly appended string into existing Amount of space allocated in p->zText*/
  if (p->nChar + N >= p->nAlloc)
  {

    /* If not, then call enlargeAndAppend(p,z,N) to expand memory to hold the appended string*/
    enlargeAndAppend(p, z, N);
  }
  else if (N)
  {

    // identify if the *p is null or don't contain any text (like [char *name] where I haven't defined any value)
    assert(p->zText);

    // update the Length of the string after the 'z' string is appended
    p->nChar += N;

    // this is important because we store the user inserted data into our device (specifically in the memory)
    // so we have to store them in device memory
    // so they've used memcpy(DEST, SRC, N), string.h function to Copy N bytes of SRC to DEST.
    memcpy(&p->zText[p->nChar - N], z, N);
  }
}
